---
layout: post
title:  "Julia Package Setup Tutorial"
date:   2021-07-16
author: Brian Jackson
categories: tutorial 
tags: robotics cmu julia
---

## Objective
The objective of this post is to provide a detailed and easy-to-follow guide for setting up a new package in Julia, complete with continuous integration, code coverage, and documentation.
At the end I will also provide some workflow tips for newcomers to Julia. This tutorial uses both GitHub and VSCode, and several steps are unique to these tools. If you use different tools, feel free to ignore these steps and adapt them to the tooling of your choice. 

For the duration of this tutorial we'll be working with a hypothetical new package called `NewPackage.jl`.

## Part I: Setting up a New Repository

### Step 1: Create a new temporary repo on your computer
In your terminal, go to a convenient location where you can create a temporary local directory. Open a Julia REPL, enter the package manager using `]`, and enter `generate NewPackage`:

!["Generate a new package in the REPL](/assets/julia_tutorials/new_package_generate.png)

This will create a local directory called `NewPackage` with the following contents:

```
src/
  NewPackage.jl
Project.toml
```

### Step 2: Create a new GitHub repository
In GitHub, create a new repository named "NewPackage.jl" (note the trailing .jl extension). Be sure to create an EMPTY repo (don't initialize it with a `README.md`, `.gitignore`, or license file). You should get a screen that looks like the following:

!["New GitHub package"](/assets/julia_tutorials/github_new_package.png)

Follow the the steps listed in the page, which are included again here:
```shell
echo "# NewPackage.jl" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/bjack205/NewPackage.jl.git
git push -u origin main
```

### Step 3: Add a `.gitignore` file 
In GitHub, add a file using "Add File | Create New File", located on the main page:

!["Add new GitHub file"](/assets/julia_tutorials/github_new_file.png)

Add a new `.gitignore` file, and optionally pick a template using the template selector that pops up on the top-right of the edit window once you enter `.gitignore` into the file name field.

The default Julia `.gitignore` is a great place to start, but feel free to edit it as needed:
```
# Files generated by invoking Julia with --code-coverage
*.jl.cov
*.jl.*.cov

# Files generated by invoking Julia with --track-allocation
*.jl.mem

# System-specific files and directories generated by the BinaryProvider and BinDeps packages
# They contain absolute paths specific to the host computer, and so should not be committed
deps/deps.jl
deps/build.log
deps/downloads/
deps/usr/
deps/src/

# Build artifacts for creating documentation generated by the Documenter package
docs/build/
docs/site/

# File generated by Pkg, the package manager, based on a corresponding Project.toml
# It records a fixed state of all packages used by the project. As such, it should not be
# committed for packages, but should be committed for applications that require a static
# environment.
Manifest.toml
```

After editing, commit the file, either directly to the main branch or via a PR (which you should keep open for the next step).

### Step 4: Add a `LICENCE` file
Again using GitHub, add a new file named `LICENSE` and use the license template selector that appears to pick a license. The MIT License is a good default.

Commit the file directly to the main branch, or to the new branch you created for your pull request in the previous step. Then merge your PR (possibly with a squash merge) to add both files.

### Step 5: Add the repo to your local `dev` folder
Back in your Julia REPL, still in the package manager, add your new package to your `~/.julia/dev` folder using the `dev` command in the package manager:

!["Dev the new package"](/assets/julia_tutorials/dev_package.png)

This will clone your repo into `~/.julia/dev/NewPackage`, which is on the Julia package search path, so that you can type `using NewPackage` anywhere on your system and it will load your package. You can now delete the original folder we created in our temporary location.

While I usually find it helpful to keep all my packages in the `dev` folder, alternatively you could keep the original location and "register" that local location instead of the remote GitHub repo using `dev /path/to/your/repo/NewPackage` instead of the step above. This downside to this approach is that it hard-codes a local path into your Manifest file which makes it non-portable to other users. If you only ever do this for you top-level (default) Julia environment, this is probably fine.

## Part II: Develop your repo

### Step 6: Setup VSCode for Julia
Assuming you've installed VSCode, launch VSCode and open the directory containing your new package. Add the [Julia VSCode Extension](https://marketplace.visualstudio.com/items?itemName=julialang.language-julia). I personally like to change the following setting to provide inline results for easy scripting:
```json
"julia.execution.resultType": "inline"
```

### Step 7: Add package dependencies
To add Julia dependencies to your project, launch the internal VSCode REPL (using the `Julia: Start REPL` command from the command palette), and activate the package environment using `activate .` in the package manager:

!["Activate project"](/assets/julia_tutorials/activate_project.png)

Once you've activated the project environment, add packages using the package manager as you would normally. These packages will automatically get added to your `Project.toml` and `Manifest.toml` files. Let's add
the [StaticArrays](https://github.com/JuliaArrays/StaticArrays.jl) package:

!["Add Static Arrays"](/assets/julia_tutorials/add_static_arrays.png)

You can see we added version `v1.2.12`. We'll add this to our `compat` section in our `Project.toml` file:
```toml
# [Project.toml]
name = "NewPackage"
uuid = "dc5d4f81-afb5-4095-bce9-9c33265b931d"
authors = ["Brian Jackson <bjack205@gmail.com>"]
version = "0.1.0"

[deps]
StaticArrays = "90137ffa-7385-5640-81b9-e52037218182

[compat]
StaticArrays = "1.2"
```

In our `src/NewPackage.jl` file, include StaticArrays.jl:
```julia
module NewPackage

using StaticArrays

greet() = print("Hello World!")

end # module
```

#### `using` vs `import`
When incorporating external projects, you have the option of either `using` or `import`, e.g.
```julia
using StaticArrays
```
or
```julia
import StaticArrays
```
The first option will bring all exported symbols into your package. For a ubiquitous package like StaticArrays, or any of the Julia standard libraries, this is usually nice since most developers are familiar withthe API these packages export.

The second option does not import anything from the package, and all commands must be explicitly imported or prefixed with the package name, e.g.
```julia
A = StaticArrays.@SMatrix rand(10,10)
```
Consider using this as the default for external packages so that it's clear to outsiders where the variousmethods you're using come from. For convenience, you can explicitly bring in symbols as needed, e.g.:
```julia
using StaticArrays: @SMatrix
```
or you can create an alias for the package name, e.g.:
```julia
const SA = StaticArrays
A = SA.@SMatrix
```
or, as of Julia v1.6, you can do this directly in the `import` command:
```julia
import StaticArrays as SA
```

### Step 8: Set up test suite 
Add a new top-level `test` folder to your repo and add a `runtests.jl` file inside. This is the launch point for your test suite and should be included in every Julia package / application that uses a test suite.

A basic `runtests.jl` file should look like:

```julia
# [test/runtests.jl]
using NewPackage
using Test

# Test scripts
include(...)
...
```
where the last part simply includes test suites defined in other files within the `test` folder. We'll addone after the next section.

### Step 9: Add test-specific dependencies
With our `test` directory set up, we now need to add our test-specific dependencies, importantly including the `Test` standard library. Again the in REPL package manager, activate the test folder using `activate test`:

!["Activate test folder"](/assets/julia_tutorials/activate_test.png)

Add, at a minimum, the [Julia `Test` library](https://docs.julialang.org/en/v1/stdlib/Test/):

!["Add Test"](/assets/julia_tutorials/add_test_library.png)

Your directory structure should now look like:

```
src/
  NewPackage.jl
test/
  Project.toml
  runtests.jl
.gitignore
Project.toml
README.md
```
### Step 10: Add some code and a unit test
We'll now add some code to our package and check functionality with a unit test. 

Add a `foo.jl` file in the `src` directory:
```julia
# [src/foo.jl]
"""
    foo(x, y)

Creates a 2-element static array from the scalars `x` and `y`.
"""
function foo(x::Number, y::Number)
    SA[x, y]
end
```

To add this file to our project, include it in `src/NewPackage.jl`:
```julia
# [src/NewPackage.jl]
module NewPackage

using StaticArrays

greet() = print("Hello World!")

include("foo.jl")

end # module
```

Now let's create a test to make sure it works as expected. Create a `test/foo_test.jl` file:
```julia
# [test/foo_test.jl]
@testset "Foo test" begin
    v = NewPackage.foo(10,5)
    @test v[1] == 10
    @test v[2] == 5
    @test eltype(v) == Int
    v = NewPackage.foo(10.0, 5)
    @test v[1] == 10
    @test v[2] == 5
    @test eltype(v) == Float64
end
```

You can run the test suite locally from the package manager by entering `test NewPackage`. It's usually best to run this command from the default environment (which you can return to using `activate` without any arguments).

If your tests pass, commit your changes to git before continuing.

## Part III: Adding CI

### Step 11: Add the CI GitHub Action
To enable CI, add the following script to `.github/workflows/`:
```yaml
# [.github/workflows/CI.yml]
name: CI
on:
  push:
    branches:
      - main 
    tags: '*'
  pull_request:
jobs:
  test:
    name: Julia ${{ matrix.version }} - ${{ matrix.os }} - ${{ matrix.arch }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        version:
          - '1.6'
        os:
          - ubuntu-latest
          - macOS-latest
          - windows-latest
        arch:
          - x64
    steps:
      - uses: actions/checkout@v2
      - uses: julia-actions/setup-julia@latest
        with:
          version: ${{ matrix.version }}
          arch: ${{ matrix.arch }}
      - uses: julia-actions/julia-buildpkg@v1
      - uses: julia-actions/julia-runtest@latest
      - uses: julia-actions/julia-uploadcodecov@latest
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
      - uses: codecov/codecov-action@v2
```
Commit the file, and push to GitHub. Under the "Actions" tab in GitHub, you should see the CI action start. If you wait a few minutes, you should see your tests pass.

### Step 12: Add Code Coverage with CodeCov.io
It's usually a good idea to get a feel for how much of your code is being covered by your test suite. We can get the reports automatically from our CI we set up in the previous step using [codecov.io](https://about.codecov.io/). If you haven't already, log in using your GitHub account. It should prompt you to set up CodeCov for your personal account and for any organizations you have the appropriate permissions for. 
After going through the setup process, you should be able to enable CodeCov for your new repo by going to your user settings and selecting the "Applications" menu on the left. You should see CodeCov under the list of Installed GitHub Apps. If you select "Configure" and scroll to the bottom uner "Repository access," you can add your repo there if you haven't enabled it for all repositories by default.

After a successful CI run, your coverage results should be automatically uploaded to codecov.io where you can view the report. This app will automatically run checks on each PR and commit to the main branch.

### Step 13: Add Other Workflows
The following workflow files are also useful:

Create a PR when one of your package dependencies releases a new version.
```yaml
# [.github/workflows/CompatHelper.yml]
name: CompatHelper
on:
  schedule:
    - cron: '00 00 * * *'
jobs:
  CompatHelper:
    runs-on: ubuntu-latest
    steps:
      - name: Pkg.add("CompatHelper")
        run: julia -e 'using Pkg; Pkg.add("CompatHelper")'
      - name: CompatHelper.main()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: julia -e 'using CompatHelper; CompatHelper.main()'
```

Automatically create a new tag when you create a release:
```yaml
# [.github/workflows/TagBot.yml]
name: TagBot
on:
  issue_comment:
    types:
      - created
  workflow_dispatch:
jobs:
  TagBot:
    # THIS 'if' LINE IS NEW
    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'
    # NOTHING BELOW HAS CHANGED
    runs-on: ubuntu-latest
    steps:
      - uses: JuliaRegistries/TagBot@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ssh: ${{ secrets.DOCUMENTER_KEY }}
```

Check formatting:
```yaml
# [.github/workflows/Formattting.yml]
name: format-check
on:
  push:
    branches:
      - 'master'
      - 'release-'
    tags: '*'
  pull_request:

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        julia-version: [1.3.0]
        julia-arch: [x86]
        os: [ubuntu-latest]
    steps:
      - uses: julia-actions/setup-julia@latest
        with:
          version: ${{ matrix.julia-version }}

      - uses: actions/checkout@v1
      - name: Install JuliaFormatter and format
        # This will use the latest version by default but you can set the version like so:
        #
        # julia  -e 'using Pkg; Pkg.add(PackageSpec(name="JuliaFormatter", version="0.13.0"))'
        run: |
          julia  -e 'using Pkg; Pkg.add(PackageSpec(name="JuliaFormatter"))'
          julia  -e 'using JuliaFormatter; format("src", verbose=true)'
      - name: Format check
        run: |
          julia -e '
          out = Cmd(`git diff --name-only`) |> read |> String
          if out == ""
              exit(0)
          else
              @error "Some files have not been formatted !!!"
              write(stdout, out)
              exit(1)
          end'
```
The last one is very optional, but useful. You can use the associated [JuliaFormatter](https://github.com/domluna/JuliaFormatter.jl) package and [VSCode extension](https://marketplace.visualstudio.com/items?itemName=singularitti.vscode-julia-formatter) to automatically format your code.


